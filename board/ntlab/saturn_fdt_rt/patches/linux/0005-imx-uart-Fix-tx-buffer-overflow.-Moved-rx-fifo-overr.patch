From 929cf72936e45b28f2a2bc21a5ab9f8e1df1b469 Mon Sep 17 00:00:00 2001
From: Andrey Mihadyuk <mihadyuk@ntlab.com>
Date: Thu, 6 Oct 2016 11:18:35 +0300
Subject: [PATCH] imx uart: Fix tx buffer overflow. Moved "rx fifo overrun"
 into trace_printk.

---
 drivers/tty/serial/imx.c | 24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index c9bd603..bfcb7cc 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -44,6 +44,8 @@
 #include <linux/platform_data/serial-imx.h>
 #include <linux/platform_data/dma-imx.h>
 
+#include <linux/ftrace.h>
+
 /* Register definitions */
 #define URXD0 0x0  /* Receiver Register */
 #define URTX0 0x40 /* Transmitter Register */
@@ -480,13 +482,15 @@ static inline void imx_transmit_buffer(struct imx_port *sport)
 		}
 	}
 
-	while (!uart_circ_empty(xmit) &&
-	       !(readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)) {
-		/* send xmit->buf[xmit->tail]
-		 * out the port here */
-		writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		sport->port.icount.tx++;
+	if (!sport->dma_is_enabled) {
+		while (!uart_circ_empty(xmit) &&
+			   !(readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)) {
+			/* send xmit->buf[xmit->tail]
+			 * out the port here */
+			writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			sport->port.icount.tx++;
+		}
 	}
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
@@ -509,7 +513,8 @@ static void dma_tx_callback(void *data)
 
 	/* update the stat */
 	spin_lock_irqsave(&sport->port.lock, flags);
-	xmit->tail = (xmit->tail + sport->tx_bytes) & (UART_XMIT_SIZE - 1);
+	if (!uart_circ_empty(xmit))
+		xmit->tail = (xmit->tail + sport->tx_bytes) & (UART_XMIT_SIZE - 1);
 	sport->port.icount.tx += sport->tx_bytes;
 	spin_unlock_irqrestore(&sport->port.lock, flags);
 
@@ -756,7 +761,8 @@ static irqreturn_t imx_int(int irq, void *dev_id)
 		writel(USR1_AWAKE, sport->port.membase + USR1);
 
 	if (sts2 & USR2_ORE) {
-		dev_err(sport->port.dev, "Rx FIFO overrun\n");
+		/*dev_err(sport->port.dev, "Rx FIFO overrun\n");*/
+		trace_printk("%p: Rx FIFO overrun \n", sport->port.membase);
 		sport->port.icount.overrun++;
 		writel(USR2_ORE, sport->port.membase + USR2);
 	}
-- 
2.10.0

